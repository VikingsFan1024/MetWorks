# DDI Project Context - Session Summary

**Date:** 2026-01-02  
**Repository:** `/srv/repos/MetWorks`  
**Solution:** `metworks-ddi-gen.sln`  
**Primary Developer:** Dan (experienced developer learning modern .NET testing practices)

---

## Project Overview

**MetWorks** is a monorepo containing a **Declarative Dependency Injection (DDI)** code generator. The project generates C# dependency injection code from YAML configuration files.

### Core Concept
- Input: YAML file defining classes, interfaces, and named instances
- Output: Generated C# code for dependency injection (Registry pattern)
- Goal: Compile-time safe DI with zero reflection overhead

### Key Design Principles
1. **Parameterless constructors required** - All classes use `new()` construction
2. **Async initialization** - Classes have optional `InitializeAsync` methods for configuration
3. **Define before reference** - YAML enforces topological ordering (prevents circular dependencies)
4. **Single-pass processing** - Simple, fast, predictable

---

## Repository Structure

```
/srv/repos/MetWorks/
├── src/DdiCodeGen/
│   ├── Generator/              # Code generation logic
│   │   ├── CodeGenerator.cs    # Main generator orchestrator
│   │   ├── TemplateRenderer.cs # Handlebars.NET wrapper
│   │   └── Models/             # Template data models
│   ├── SyntaxLoader/           # YAML parsing (recently simplified)
│   ├── TemplateStore/          # Template storage (embedded resources)
│   │   └── Templates/          # Handlebars templates
│   │       ├── *.hbs           # Main templates
│   │       └── _partials/      # Reusable template fragments
│   └── Shared/                 # Common utilities
├── tests/DdiCodeGen/
│   ├── Generator/              # Generator tests
│   └── SyntaxLoader/           # Loader tests
│       └── LoadAndTransformTests.cs
└── docs/
    ├── declarative-di.md           # Current implementation docs
    ├── DDI-FUTURE-FEATURES.md      # Planned features (constructor params, scopes, lazy loading)
    ├── TEMPLATE-REFACTORING-GUIDE.md
    └── PARTIALS-IMPLEMENTATION.md
```

---

## Recent Simplification Work

**Context:** Dan spent the past week simplifying code originally generated by GitHub Copilot Web. The AI-generated code was functional but overly complex and inconsistent.

### What Was Removed/Simplified
1. **Eliminated Canonical/Semantic parsing layers** - Unnecessary abstraction
2. **Removed orphaned templates** - Cleaned up unused Registration, PrimitiveArray, NamedInstanceAccessor templates
3. **Removed dead TemplateEngine code** - Found in TemplateStore (wasn't actually used)
4. **Simplified architecture** - Direct flow: YAML → SyntaxLoader → Models → CodeGenerator → .g.cs files

### Current Active Templates (6)
1. `Registry.hbs` - Main registry class (CreateAll, InitializeAllAsync, DisposeAll)
2. `Registry.Accessors.hbs` - Dual accessor pattern (external=interface, internal=concrete)
3. `Registry.InstanceFactory.hbs` - Per-instance factory methods
4. `Registry.InstanceField.hbs` - Backing field declarations
5. `Assignments.Initializer.hbs` - Async initialization for assignment-driven instances
6. `Elements.Initializer.hbs` - Array construction for element-driven instances

---

## Current Session Work: Template Partials

### Problem Being Solved
Templates had duplicated code (file headers, accessor patterns). Handlebars.NET supports partials (reusable template fragments), so we're refactoring to use them.

### Partials Created
Location: `src/DdiCodeGen/TemplateStore/Templates/_partials/`

1. **`Common.FileHeader.hbs`** - Standard file header (template name, timestamp, `#nullable enable`)
2. **`Registry.AccessorTriple.hbs`** - Register + Get (external) + Get_Internal (internal) accessor pattern

### Implementation Status
- ✅ Partials created
- ✅ Example refactored template created (`Registry.Accessors.REFACTORED.hbs`)
- ✅ Documentation written
- ⏳ **IN PROGRESS:** Implementing `TemplateRenderer` with partial support

### Key Design Decisions Made

#### 1. Partials Use Dot Notation
- File: `_partials/Common.FileHeader.hbs`
- Registered as: `"Common.FileHeader"`
- Used as: `{{> Common.FileHeader TemplateName="Registry" GeneratedHeader=GeneratedHeader}}`

#### 2. Instance-Based TemplateRenderer (Not Static)
**Reason:** Testability and dependency injection

```csharp
// Chosen approach
public sealed class TemplateRenderer
{
    public TemplateRenderer(ITemplateStore store) { ... }
    public string Render(string template, object ctx) { ... }
}
```

**Why not static:**
- ❌ Can't inject dependencies
- ❌ Can't mock for testing
- ❌ Hard-coded coupling

#### 3. On-Demand Partial Loading
**Using Handlebars.NET's built-in `UnresolvedPartialHandler`:**

```csharp
var config = new HandlebarsConfiguration
{
    UnresolvedPartialHandler = (partialName, source) =>
    {
        // Load from ITemplateStore on-demand
        return store.GetTemplate($"_partials.{partialName}");
    }
};
```

**Benefits:**
- ✅ Separation of concerns (storage vs processing)
- ✅ Lazy loading (only load used partials)
- ✅ No factory needed
- ✅ Testable with mock `ITemplateStore`

---

## Architecture Patterns

### Storage Abstraction
```csharp
public interface ITemplateStore
{
    string GetTemplate(string name);
    IEnumerable<string> ListTemplates();
}

public sealed class TemplateStore : ITemplateStore
{
    // Loads templates from embedded resources
}
```

### Generated Code Pattern (3-Phase Lifecycle)
```csharp
public partial class Registry
{
    // Phase 1: Creation (synchronous)
    public void CreateAll()
    {
        // Calls *_InstanceFactory.Create() for each instance
    }

    // Phase 2: Initialization (asynchronous)
    public async Task InitializeAllAsync()
    {
        // Calls *_Initializer.Initialize_*Async() for instances with assignments
    }

    // Phase 3: Disposal (planned, not yet implemented)
    public void DisposeAll()
    {
        // Future: calls *_Disposer.Dispose() for IDisposable instances
    }
}
```

### Dual Accessor Pattern
External consumers get interface types (API safety), internal code gets concrete types (flexibility):

```csharp
// External accessor
public IFileLogger GetTheFileLogger() => _TheFileLoggerInstance;

// Internal accessor
internal FileLogger GetTheFileLogger_Internal() => _TheFileLoggerInstance;
```

---

## Testing Approach

### Framework
- **xUnit** - Modern .NET testing framework
- **Learning journey** - Dan is an experienced developer learning modern testing tools

### Testing Philosophy Learned
> "Testability isn't just about tests - it's about design quality"

**Key insight from today:** Designing for testability (dependency injection, separation of concerns) leads to better architecture even without tests.

### Test Location
Primary test file: `tests/DdiCodeGen/SyntaxLoader/LoadAndTransformTests.cs`

Current test structure:
```csharp
[Fact]
public void Generate_Registry_Accessor_From_Input_Structure()
{
    var templateStore = new TemplateStore();
    var renderer = new TemplateRenderer(templateStore);
    
    var model = new Registry { /* ... */ };
    
    var template = templateStore.GetTemplate("Registry.Accessors");
    var result = renderer.Render(template, model);
    
    // Assert on result
}
```

---

## Known Issues / Current Work

### 1. MSBuild Project Name Ambiguity
**Issue:** Had two projects named `Generator.csproj`:
- `src/DdiCodeGen/Generator/Generator.csproj`
- `tests/DdiCodeGen/Generator/Generator.Tests.csproj`

**Problem:** MSBuild resolves by filename, not full path, causing ambiguity.

**Solution:** Will rename to use namespace-based names:
- `DdiCodeGen.Generator.csproj`
- `DdiCodeGen.Generator.Tests.csproj`

### 2. Template Rendering with Partials (IN PROGRESS)
**Current task:** Update `TemplateRenderer.cs` to support partial resolution

**Approach chosen:**
```csharp
public sealed class TemplateRenderer
{
    private readonly IHandlebars _handlebars;
    
    public TemplateRenderer(ITemplateStore store)
    {
        var config = new HandlebarsConfiguration
        {
            UnresolvedPartialHandler = (partialName, source) =>
            {
                // Resolve from store on-demand
            }
        };
        _handlebars = Handlebars.Create(config);
    }
    
    public string Render(string template, object ctx)
    {
        var compiled = _handlebars.Compile(template);
        return compiled(ctx);
    }
}
```

**Next steps:**
1. Implement partial resolution logic
2. Test with `LoadAndTransformTests.cs`
3. Verify generated output matches existing files
4. Migrate remaining 5 templates to use partials

---

## Future Features (Deferred)

Documented in `docs/DDI-FUTURE-FEATURES.md`:

1. **Constructor Parameter Support** - Allow classes with parameterized constructors
2. **Lifetime Scopes** - Support Singleton, Scoped, Transient (with MS DI integration)
3. **Lazy Creation** - `eagerLoad: false` flag for on-demand instantiation
4. **Lazy Initialization** - `lazyInitialization: true` for deferred `InitializeAsync` calls
5. **Combined Lazy** - Both creation and initialization deferred

**Note:** Registration templates (for MS DI integration) were removed as orphaned code during simplification.

---

## Key Files to Reference

### Most Important
- `src/DdiCodeGen/Generator/CodeGenerator.cs` - Main generation orchestrator
- `src/DdiCodeGen/Generator/TemplateRenderer.cs` - **Current work: adding partial support**
- `src/DdiCodeGen/TemplateStore/ITemplateStore.cs` - Storage interface
- `tests/DdiCodeGen/SyntaxLoader/LoadAndTransformTests.cs` - Test file

### Templates
- `src/DdiCodeGen/TemplateStore/Templates/Registry.Accessors.hbs` - Target for partial refactoring
- `src/DdiCodeGen/TemplateStore/Templates/_partials/Common.FileHeader.hbs`
- `src/DdiCodeGen/TemplateStore/Templates/_partials/Registry.AccessorTriple.hbs`

### Documentation
- `docs/declarative-di.md` - Implementation reference
- `docs/PARTIALS-IMPLEMENTATION.md` - Step-by-step partial implementation guide
- `docs/DDI-FUTURE-FEATURES.md` - Roadmap of deferred features

### Example YAML
- `tests/DdiCodeGen/Generator/fixtures/maximal-valid.yaml` - Comprehensive example
- `tests/DdiCodeGen/SyntaxLoader/fixtures/maximal-valid.yaml` - Test fixture

### Generated Output (for comparison)
- `tests/DdiCodeGen/Generator/WorkingTemplateSet/*.g.cs` - Known good generated files
- `tests/DdiCodeGen/SyntaxLoader/bin/Debug/net10.0/GeneratedFiles/*.g.cs` - Latest test output

---

## Developer Context (Dan)

### Background
- Experienced developer (pre-2020s .NET experience)
- Learning modern .NET practices: xUnit, Moq, modern DI patterns
- "Teaching this old dog new tricks" - but the experience is valuable
- Strong understanding of design principles, now applying modern tools

### Working Style
- Prefers understanding concepts deeply before implementing
- Values simplicity and consistency over complexity
- Willing to delete working code to achieve better design
- Learning by doing (working through one template refactoring manually)

### Key Insights Gained Today
1. **Testability = Good Design** - Even without tests, designing for testability improves architecture
2. **Static vs Instance** - Instance-based with DI is almost always better for services with dependencies
3. **Static Interfaces** - Good for exposing static utility classes safely, but don't solve testability issues
4. **Separation of Concerns** - Storage and processing should be independent (achieved via `UnresolvedPartialHandler`)

---

## Commands & Environment

### Build & Test
```bash
cd /srv/repos/MetWorks
dotnet restore metworks-ddi-gen.sln
dotnet build metworks-ddi-gen.sln
dotnet test metworks-ddi-gen.sln --no-build
```

### Find Generated Files
```bash
# Latest test output
ls tests/DdiCodeGen/SyntaxLoader/bin/Debug/net10.0/GeneratedFiles/

# Known good output
ls tests/DdiCodeGen/Generator/WorkingTemplateSet/
```

### Useful Searches
```bash
# Find all .hbs templates
find src/DdiCodeGen/TemplateStore/Templates -name "*.hbs"

# Find where Handlebars.Compile is called
grep -r "Handlebars.Compile" src/DdiCodeGen/Generator/
```

---

## Session End State

### Completed Today
1. ✅ Discussed ExpandoObject (avoid for type safety)
2. ✅ Discussed Handlebars.NET capabilities
3. ✅ Analyzed template structure and identified orphaned templates
4. ✅ Cleaned up 9 orphaned templates
5. ✅ Created partial infrastructure (`_partials/` directory)
6. ✅ Created 2 initial partials (FileHeader, AccessorTriple)
7. ✅ Created comprehensive documentation
8. ✅ Designed `TemplateRenderer` with on-demand partial loading
9. ✅ Understood testability principles and their impact on design

### Current State
- **In Progress:** Implementing `TemplateRenderer` with partial support
- **Test File:** `LoadAndTransformTests.cs` ready for validation
- **Next Action:** Dan will implement and test partial resolution

### What to Resume With
When starting a new session, provide this document and say:

> "I'm continuing work on the DDI template partial refactoring. I'm implementing `TemplateRenderer` to support on-demand partial loading using Handlebars.NET's `UnresolvedPartialHandler`. Current status: [describe where you are]"

---

## Quick Reference: Core Concepts

### YAML → Code Flow
```
YAML file
  ↓
SyntaxLoader.Load()
  ↓
Model objects (Registry, Instance, etc.)
  ↓
CodeGenerator.GenerateFiles()
  ↓
TemplateStore.GetTemplate() → Handlebars templates
  ↓
TemplateRenderer.Render() → Applies model to template
  ↓
Generated .g.cs files
```

### Template Model Structure (Example)
```csharp
public class Registry
{
    public string Namespace { get; set; }
    public string ClassQualified { get; set; }
    public string Header { get; set; }
    public List<Instance> Instances { get; set; }
}

public class Instance
{
    public string Name { get; set; }
    public string ClassQualified { get; set; }
    public string? InterfaceQualified { get; set; }
    public string BackingPropertyName { get; set; }
    public bool HasAssignments { get; set; }
    public bool HasElements { get; set; }
}
```

### Handlebars Partial Syntax
```handlebars
{{!-- Include partial with parameters --}}
{{> Common.FileHeader TemplateName="Registry" GeneratedHeader=GeneratedHeader}}

{{!-- Include partial with context object --}}
{{#each Instances}}
{{> Registry.AccessorTriple this}}
{{/each}}
```

---

**End of Context Document**

_This document should be provided at the start of future sessions to restore context quickly._
